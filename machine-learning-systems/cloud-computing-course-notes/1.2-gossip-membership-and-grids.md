# 1.2 Gossip, Membership, and Grids

## Lesson 1: Gossip

### Multicast Problem

* In computer networking, multicast is group communication where data transmission is addressed to a group of destination computers simultaneously
* Multicast can be one-to-many or many-to-many distribution
* The difference between multicast and broadcast is that in broadcast, the packet is delivered to all the hosts connected to the network, whereas in multicast, the packet is delivered to intended recipients only.
* The multicast protocol typically sits at the application layer \(i.e., does not deal with the underlying network\)
* Challenges
  * Fault-Tolerance
    * Nodes may crash
    * Packets may be dropped
  * Scalability
    * Tens of thousands of nodes
* Simplest implementation: Centralized
  * The sender sends in a loop UDP/TCP packets
  * Problems
    * Not fault-tolerant: Sender may fail. Say it fails halfway through, only half of the receivers get the message
    * High overhead: Not scalable -&gt; high O\(N\) latency
* Solution: Tree-Based implementation
  * Pro: For a good \(balanced\) tree, the height is O\(log\(N\)\) -&gt; better latency
  * Con: High set up and maintenance costs
* Tree-Based multicast protocols
  * Build spanning trees to disseminate multicasts
  * Use ACKs or NAKs to repair multicasts not received
  * SRM: Scalable Reliable Multicast
    * Uses NAKs
    * Uses random delays \(before sending out repair request\) and exponential backoff \(if sending out multiple NAKs, doubles the wait time every time they wait\) to avoid NAK storms
  * RMTP: Reliable Multicast Transport Protocol
    * Uses ACKs
    * ACKs are only sent to designated receivers, which then re-transmit missing multicasts
* Studies show that despite these countermeasures, these protocols still suffer from O\(N\) ACK/NAK overheads, which motivated the development of gossip/epidemic protocols

### Gossip Protocols

* There are two "hyperparameters": t and b. Say we set t to be 5 seconds and b \(fan-out\) to be 2 nodes. In the following examples, we consider only 1 multicast message and only 1 sender.
* Periodically \(every t seconds\), a sender picks b random targets and sends them the multicast/gossip message. We can use UDP to transmit the messages as the gossip protocol itself is very reliable.
* Once a node receives its gossip, it is said to be "infected" and becomes a sender. 
* The gossip protocol is not synchronized across nodes: each node uses its local clock to send messages in rounds. When doing analyses, we typically assume them to be synchronized, though.
* Those above described the "push" gossip: once you have a multicast message, you start gossiping about it.
  * There is also a "pull" gossip that periodically polls randomly selected processes for new multicast messages that haven't been received. 
  * Another variant is the push-pull model. In this model, when sending out a pull query, the sender also includes some gossip messages it received recently.
* Multiple messages -&gt; push a random subset/recently-received ones/high-priority ones

![In this example, we start with one sender at the bottom left corner](../../.gitbook/assets/screen-shot-2021-06-28-at-7.29.07-am.png)

### Gossip Analysis



### Gossip Implementations

